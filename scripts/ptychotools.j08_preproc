#!/usr/bin/env python
"""
Pre-processing of ptychography data collected at J08 endstation
"""

import os
import sys
import json
import h5py
import argparse
import subprocess
import numpy as np

parser = argparse.ArgumentParser(prog="ptychotools.dawn_processing", description="Pre-processing of ptychography data collected at J08 endstation")
parser.add_argument("-i", "--input", type=str,
                    help="Input file path to nexus file")
parser.add_argument("-o", "--output", type=str, 
                    help="Output file path for processed file")
parser.add_argument("-d", "--dataset", type=str,
                    help="Key to dataset inside nexus file")
parser.add_argument("-r", "--scanrank", type=int,
                    help="The rank of the scan")
parser.add_argument("--posx", type=str, dest="posx",
                    help="Key to X motor position (readback values)")
parser.add_argument("--posy", type=str, dest="posy",
                    help="Key to Y motor position (readback values)")
parser.add_argument("--posx-set", type=str, dest="posx_set",
                    help="Key to X motor position (set values)")
parser.add_argument("--posy-set", type=str, dest="posy_set",
                    help="Key to Y motor position (set values)")
parser.add_argument("-s", "--shape-check", dest="shape", type=bool,
                    help="Check if diffraction data and motor positions match in shape") 
parser.add_argument("-m", "--multi-trigger-check", dest="multi", type=bool,
                    help="Check if there are mutliple readback motor positions per set motor position")
parser.add_argument("-t", "--topup-check", dest="topup", type=bool, 
                    help="Check if the scan went through the top-up and fix the data")
args = parser.parse_args()

# Parse processing pargs
processed_filepath = args.output
nexus_filepath = args.input
dataset = args.dataset
scan_rank = args.scanrank

# If the target already exists, there is nothing to do
if (os.path.isfile(processed_filepath)):
    sys.exit("Nothing to do here, a processed file already exists: %s" %processed_filepath)


def subtract_darkframe(frame, dark):
    """
    subtracts a dark image from a given frame
    and replaces negative values with zeros.
    """
    corrected = frame - dark
    corrected[frame<dark] = 0
    return corrected

# Write dark-processed data into a new file
with h5py.File(processed_filepath, "w") as pf:
    with h5py.File(nexus_filepath, "r") as nf:

        # Data handles
        raw = nf[dataset]
        dark = nf["entry/instrument/darkFieldCollector/darkField"] # todo:  replace with parameter
        
        # Create processed data
        d = pf.create_dataset("processed/result/data", raw.shape, dtype=raw.dtype)

        # Dark correction and write to processed data
        if scan_rank == 2:
            for j in range(raw.shape[0]):
                for i in range(raw.shape[1]):
                    d[j,i] = subtract_darkframe(raw[j,i], dark[0])
        elif scan_rank == 1:
            for i in range(raw.shape[0]):
                d[i] = subtract_darkframe(raw[i], dark[0])
        else:
            sys.exit("Unknown scan rank: %d" %scan_rank)
        print("Dark correction finished.")

        # Create link to nexus file
        pf["entry"] = h5py.ExternalLink(nexus_filepath, "entry")
        print("Linked /entry from original nexus file into processed file.")

# Check if motor positions have been provided
if (args.posx is None) and (args.posy is None):
    sys.exit("No key to motor positions (readback values) provided, will terminate processing here")
if (args.posx_set is None) and (args.posy_set is None):
    sys.exit("No key to motor positions (set values) provided, will terminate processing here")
print("Motor positions provided, continue with corrections...")

# Parse motor positions
with h5py.File(args.output, "r") as f:
    posx = f[args.posx][:].squeeze()
    posy = f[args.posy][:].squeeze()
    posx_set = f[args.posx_set][:].squeeze()
    posy_set = f[args.posy_set][:].squeeze()
posx_original = np.copy(posx)
posy_original = np.copy(posy)
print("Readback and set values loaded.")

# Scan rank

if (posx.ndim == 1):
    scan_rank = 1
    print("Scan rank has been reset to 1")
print("The scan rank is ", scan_rank)

# Make sure that readback values include leading dimension
if (scan_rank == 1):
    posx = np.expand_dims(posx, axis=0)
    posy = np.expand_dims(posy, axis=0)
print("Readback shape is ", posx.shape)

# Calculate origin
origin_x = posx_set[0]
origin_y = posy_set[0]
print("Origin of set values is (x,y) = (%f,%f)" %(origin_x,origin_y))

# Detect type of scan
is_mapped_arb    = (posx.ndim == 2) and (posy.ndim == 2)
is_mapped_raster = (posx.ndim == 3) and (posy.ndim == 3)
if not (is_mapped_arb or is_mapped_raster):
    sys.exit("Could not detect layout of motor positions, will terminate here")
print("A scan type has been detected (arb=%d, raster=%d)" %(int(is_mapped_arb),int(is_mapped_raster)))

# Synchronise readback/set values
if is_mapped_arb:
    posx -= (posx[0,0] - origin_x)
    posy -= (posy[0,0] - origin_y)
if is_mapped_raster:
    posx -= (posx[0,0,0] - origin_x)
    posy -= (posy[0,0,0] - origin_y)
print("Readback values have been synchronised to match set values")

# Check if the readback have been triggered multiple times
if args.multi and is_mapped_arb:
    ratio_x = posx.shape[1] // len(posx_set)
    if ratio_x > 1:
        posx = posx[:,::ratio_x]
        print("The readback values (x) have been triggered multiple times, should be fixed now")
    ratio_y = posy.shape[1] // len(posy_set)
    if ratio_y > 1:
        posy = posy[:,::ratio_y]
        print("The readback values (y) have been triggered multiple times, should be fixed now")

# Check if diffraction data and motor positions match in shape
with h5py.File(args.output, "r") as f:
    nr_data_frames = f[args.dataset].shape[args.scanrank-1]
if args.shape and is_mapped_arb:
    print(nr_data_frames, posx.shape)
    if (nr_data_frames < posx.shape[1]):
        posx = posx[:,:nr_data_frames]
        print("There was a shape mismatch between the data and the readback values (x), should be fixed now")
        print("posx shape is", posx.shape)
    if (nr_data_frames < posy.shape[1]):
        posy = posy[:,:nr_data_frames]
        print("There was a shape mismatch between the data and the readback values (y), should be fixed now")
        print("posy shape is", posy.shape)

# Squeeze
if args.scanrank == 1:
    posx = posx.squeeze()
    posy = posy.squeeze()

# Store processed motor positions
with h5py.File(args.output, "r+") as f:
    try:
        del f["processed/result/posx"]
        del f["processed/result/posy"]
    except:
        pass
    f["processed/result/posx"] = posx
    f["processed/result/posy"] = posy
